YOU ARE A CODING GOD AND I WILL NOW GIVE YOU MY DIRECTORY STRUCTURE INCLUDING ALL CODE AND THEN BELOW WILL ASK YOU A QUESTION ABOUT IT. THANK YOU FOR YOUR HELP.

CODE/
    ├── simulation.py
        -------------- CODE OF simulation.py --------------
        import matplotlib.pyplot as plt
        from matplotlib.animation import FuncAnimation
        from services.city import City
        import osmnx as ox
        from utils.constants import NORTH, SOUTH, EAST, WEST
        import numpy as np
        
        class Simulation:
            def __init__(self, city):
                self.city = city
                self.graph = city.graph  # Assuming City class has a 'graph' attribute
                self.fig, self.ax = None, None
                self.citizen_scatter = None
                self.incident_scatter = None
                self.police_scatter = None
                self.firetruck_scatter = None
        
        
            def plot_map(self):
                # Initialize a map plot
                self.fig, self.ax = plt.subplots(figsize=(20, 20), facecolor='black')
                ox.plot_graph(self.graph, ax=self.ax, node_size=0, show=False)
        
                # Set the limits of the plot to the limits of the graph
                self.ax.set_xlim([WEST, EAST])
                self.ax.set_ylim([SOUTH, NORTH])
        
                self.citizen_scatter = self.ax.scatter([], [], c='black', s=20, label='Citizens')
                self.incident_scatter = self.ax.scatter([], [], c='orange', s=75, label='Incidents', marker='s')
                self.police_scatter = self.ax.scatter([], [], c='blue', s=30, label='Police')
                self.firetruck_scatter = self.ax.scatter([], [], c='red', s=30, label='Firetrucks')
        
                self.anim = FuncAnimation(self.fig, self.refresh_map, interval=100, cache_frame_data=False)
                plt.legend()
                plt.show()
        
            def start_simulation(self):
                self.deploy_emergency_services()
                self.deploy_citizens()
                self.plot_map()
        
            def refresh_map(self, frame):
                # We need to define how to get current locations of citizens, incidents, and emergency vehicles
                citizen_nodes = [citizen.current_node for citizen in self.city.citizens]
                police_nodes = [police.current_node for police in self.city.police_onsite]
                firetruck_nodes = [firetruck.current_node for firetruck in self.city.firetrucks_onsite]
                incident_nodes = [incident.location for incident in self.city.emergency_response.active_incidents.values()]
        
                # Get coordinates for each group
                citizen_coords = [[self.graph.nodes[node]['x'], self.graph.nodes[node]['y']] for node in citizen_nodes]
                police_coords = [[self.graph.nodes[node]['x'], self.graph.nodes[node]['y']] for node in police_nodes]
                firetruck_coords = [[self.graph.nodes[node]['x'], self.graph.nodes[node]['y']] for node in firetruck_nodes]
                
                # Update scatters with new positions
                self.citizen_scatter.set_offsets(citizen_coords)
                self.police_scatter.set_offsets(police_coords)
                self.firetruck_scatter.set_offsets(firetruck_coords)
                
                # Handle incident_coords separately, checking if the list is empty
                incident_coords = [[self.graph.nodes[node]['x'], self.graph.nodes[node]['y']] for node in incident_nodes] if incident_nodes else np.empty((0, 2))
                self.incident_scatter.set_offsets(incident_coords)
        
                # We need to return a tuple of "artists" that have been changed
                return self.citizen_scatter, self.incident_scatter, self.police_scatter, self.firetruck_scatter
        
            def run(self):
                print("Starting simulation")
                self.city.start_services()
                self.plot_map()
                self.anim = FuncAnimation(self.fig, self.refresh_map, interval=200, blit=True)
                plt.legend()
                plt.show()

    ├── main.py
        -------------- CODE OF main.py --------------
        from services.city import City
        from simulation import Simulation
        
        def main():
            num_citizens = 10  # Define the number of citizens for the simulation
            my_city = City(num_citizens)  # Create an instance of the City class
            my_city.start_services() 
            simulation = Simulation(my_city)  # Create an instance of the Simulation class with the city instance
            simulation.run()  # Run the simulation
        
        if __name__ == '__main__':
            main()

    utils/
        ├── constants.py
            -------------- CODE OF constants.py --------------
            NORTH, SOUTH, EAST, WEST = 40.501416, 40.459202, -3.606143, -3.711698
            FIRE_STATION = 55243514
            AMBULANCE_STATION = 26207177
            POLICE_STATION = 2421410285
            FIRE_TRUCKS = 5
            AMBULANCES = 5
            POLICE_CARS = 5
            
            INCIDENTS = {
                        'petty_theft': {
                            'required_police_cars': 1,
                            'required_firetrucks': 0,
                            'required_ambulances': 0,
                            'hardness': 5,
                            'probability': 0.15
                        },
                        'traffic_accident_minor': {
                            'required_police_cars': 1,
                            'required_firetrucks': 0,
                            'required_ambulances': 1,
                            'hardness': 15,
                            'probability': 0.13
                        },
                        'medical_emergency': {
                            'required_police_cars': 0,
                            'required_firetrucks': 0,
                            'required_ambulances': 1,
                            'hardness': 10,
                            'probability': 0.12
                        },
                        'bar_fight': {
                            'required_police_cars': 2,
                            'required_firetrucks': 0,
                            'required_ambulances': 1,
                            'hardness': 20,
                            'probability': 0.10
                        },
                        'house_fire_small': {
                            'required_police_cars': 1,
                            'required_firetrucks': 2,
                            'required_ambulances': 1,
                            'hardness': 30,
                            'probability': 0.08
                        },
                        'vandalism': {
                            'required_police_cars': 1,
                            'required_firetrucks': 0,
                            'required_ambulances': 0,
                            'hardness': 8,
                            'probability': 0.07
                        },
                        'traffic_accident_major': {
                            'required_police_cars': 2,
                            'required_firetrucks': 1,
                            'required_ambulances': 2,
                            'hardness': 35,
                            'probability': 0.06
                        },
                        'store_robbery': {
                            'required_police_cars': 3,
                            'required_firetrucks': 0,
                            'required_ambulances': 1,
                            'hardness': 40,
                            'probability': 0.05
                        },
                        'industrial_fire': {
                            'required_police_cars': 2,
                            'required_firetrucks': 3,
                            'required_ambulances': 2,
                            'hardness': 60,
                            'probability': 0.04
                        },
                        'earthquake_minor': {
                            'required_police_cars': 3,
                            'required_firetrucks': 3,
                            'required_ambulances': 2,
                            'hardness': 70,
                            'probability': 0.01
                        },
                        'terrorist_threat': {
                            'required_police_cars': 4,
                            'required_firetrucks': 1,
                            'required_ambulances': 3,
                            'hardness': 80,
                            'probability': 0.025
                        },
                        'chemical_spill': {
                            'required_police_cars': 2,
                            'required_firetrucks': 4,
                            'required_ambulances': 2,
                            'hardness': 65,
                            'probability': 0.022
                        },
                        'wildfire': {
                            'required_police_cars': 2,
                            'required_firetrucks': 4,
                            'required_ambulances': 3,
                            'hardness': 85,
                            'probability': 0.028
                        },
                        'flood': {
                            'required_police_cars': 3,
                            'required_firetrucks': 3,
                            'required_ambulances': 3,
                            'hardness': 75,
                            'probability': 0.015
                        },
                        'earthquake_major': {
                            'required_police_cars': 5,
                            'required_firetrucks': 5,
                            'required_ambulances': 4,
                            'hardness': 100,
                            'probability': 0.010
                        },
                        'power_outage': {
                            'required_police_cars': 1,
                            'required_firetrucks': 0,
                            'required_ambulances': 0,
                            'hardness': 20,
                            'probability': 0.03
                        },
                        'gas_leak': {
                            'required_police_cars': 2,
                            'required_firetrucks': 1,
                            'required_ambulances': 1,
                            'hardness': 25,
                            'probability': 0.025
                        },
                        'public_disturbance': {
                            'required_police_cars': 2,
                            'required_firetrucks': 0,
                            'required_ambulances': 0,
                            'hardness': 15,
                            'probability': 0.02
                        },
                        'animal_rescue': {
                            'required_police_cars': 1,
                            'required_firetrucks': 1,
                            'required_ambulances': 0,
                            'hardness': 10,
                            'probability': 0.015
                        }
                    }

        ├── helpers.py
            -------------- CODE OF helpers.py --------------


        __pycache__/
            ├── constants.cpython-310.pyc
                -------------- CODE OF constants.cpython-310.pyc --------------
Failed to read constants.cpython-310.pyc: 'utf-8' codec can't decode byte 0xd3 in position 12: invalid continuation byte

    models/
        ├── emergency_vehicle.py
            -------------- CODE OF emergency_vehicle.py --------------
            from models.moving_object import MovingObject
            from models.incident import Incident
            import time
            
            
            class EmergencyVehicle(MovingObject):
                def __init__(self, id, graph, vehicle_type, home_location):
                    super().__init__(id, graph, home_location)  # Assuming starting location is the first incident's location
                    self.id = id
                    self.incident = None
                    self.vehicle_type = vehicle_type
                    self.available = True
                    self.at_home_location = True
                    self.home_location = None
            
                def attend_incident(self, incident):
                    self.set_route(incident.location)
                    super().run()
                    print(f"{self.vehicle_type} {self.id} arrived at incident at {incident.location}")
                    while not incident.resolved:
                        with incident.lock:
                            incident.hardness -= 3
                        time.sleep(1)
                        if incident.hardness <= 0:
                            with incident.lock:
                                incident.resolved = True    
                            print(f"{self.vehicle_type} {self.id} resolved incident at {incident.location}")
                    self.set_route(self.home_location)
                    super().run()
                    print(f"{self.vehicle_type} {self.id} returned to station")
                    self.at_home_location = True
                    self.available = True

        ├── incident.py
            -------------- CODE OF incident.py --------------
            import threading
            
            class Incident:
                def __init__(self, id, osmid, incident_type, time, hardness):
                    # Define properties of incident
                    self.id = id
                    self.location = osmid
                    self.incident_type = incident_type
                    self.report_time = time
                    self.hardness = hardness
                    self.status = "reported"
                    self.resolved = False
                    self.vehicles_dispatched = []
                    self.vehicles_needed = []
                    self.lock = threading.Lock()
                    print(f"Incident of type {self.incident_type} initiated at {self.location}")
            
                def __str__(self):
                    return f"ID: {self.id}, Location: {self.location}, Type: {self.incident_type}, Status: {self.status}"

        ├── citizen.py
            -------------- CODE OF citizen.py --------------
            from models.moving_object import MovingObject
            import random
            import time 
            
            class Citizen(MovingObject):
                def __init__(self, id, graph, emergency_center):
                    start_node = random.choice(list(graph.nodes()))
                    super().__init__(id, graph, start_node)
                    self.num_incidents_reported = 0
                    self.emergency_center = emergency_center
            
                def report_incident(self):
                    incident_location = self.current_node
                    self.emergency_center.report_incident(incident_location)
                    self.num_incidents_reported += 1
                    self.current_node = random.choice(list(self.graph.nodes()))
            
                def run(self):
                    while self.num_incidents_reported < 3:
                        if random.random() < 0.2:
                            self.report_incident()
                        time.sleep(10)

        ├── moving_object.py
            -------------- CODE OF moving_object.py --------------
            import threading
            import time
            import osmnx as ox
            
            class MovingObject(threading.Thread):
                def __init__(self, id, graph, start_node, route=None):
                    super().__init__()
                    self.id = id
                    self.graph = graph
                    self.current_node = start_node
                    self.lock = threading.Lock() # Lock to prevent multiple threads from accessing the same object
                    self.target_node = None  # The destination node
                    self.route = route if route is not None else []  # The path to follow
                    self.route_index = 0  # Which step we are at in the route
                    self.scatter = None  # Reference to the matplotlib scatter object
                    self.position = None  # Position for the animation (x, y coordinates)
                    
            
                # Method to calculate the path from the current_node to the target_node
                def set_route(self, target_node, weight='length'):
                    self.target_node = target_node
                    self.route = ox.shortest_path(self.graph, self.current_node, self.target_node, weight=weight)
                    self.route_index = 0
            
                def move(self):
                    while self.route and self.route_index < len(self.route) - 1:
                        self.current_node = self.route[self.route_index]
                        self.route_index += 1
                        self.position = (self.graph.nodes[self.current_node]['x'], self.graph.nodes[self.current_node]['y'])
                        return True
                    else:
                        return False 
            
                def run(self):
                    while self.move():
                        time.sleep(0.2)  # Wait between nodes

        __pycache__/
            ├── police_car.cpython-310.pyc
                -------------- CODE OF police_car.cpython-310.pyc --------------
Failed to read police_car.cpython-310.pyc: 'utf-8' codec can't decode byte 0x9f in position 9: invalid start byte

            ├── fire_truck.cpython-310.pyc
                -------------- CODE OF fire_truck.cpython-310.pyc --------------
Failed to read fire_truck.cpython-310.pyc: 'utf-8' codec can't decode byte 0x86 in position 8: invalid start byte

            ├── moving_object.cpython-310.pyc
                -------------- CODE OF moving_object.cpython-310.pyc --------------
Failed to read moving_object.cpython-310.pyc: 'utf-8' codec can't decode byte 0xcc in position 12: invalid continuation byte

            ├── incident.cpython-310.pyc
                -------------- CODE OF incident.cpython-310.pyc --------------
Failed to read incident.cpython-310.pyc: 'utf-8' codec can't decode byte 0xb1 in position 12: invalid start byte

            ├── emergency_vehicle.cpython-310.pyc
                -------------- CODE OF emergency_vehicle.cpython-310.pyc --------------
Failed to read emergency_vehicle.cpython-310.pyc: 'utf-8' codec can't decode byte 0xe8 in position 12: invalid continuation byte

            ├── citizen.cpython-310.pyc
                -------------- CODE OF citizen.cpython-310.pyc --------------
Failed to read citizen.cpython-310.pyc: 'utf-8' codec can't decode byte 0xe3 in position 16: invalid continuation byte

    __pycache__/
        ├── simulation.cpython-310.pyc
            -------------- CODE OF simulation.cpython-310.pyc --------------
Failed to read simulation.cpython-310.pyc: 'utf-8' codec can't decode byte 0xe3 in position 16: invalid continuation byte

    services/
        ├── city.py
            -------------- CODE OF city.py --------------
            import osmnx as ox
            import threading
            from models.citizen import Citizen
            from models.emergency_vehicle import EmergencyVehicle
            from utils.constants import *
            from services.emergency_response_center import EmergencyResponseCenter
            
            
            class City:
                def __init__(self, citizens_number):
                    self.citizens_number = citizens_number
                    self.citizens = []
                    self.firetrucks_onsite = []
                    self.police_onsite = []
                    self.ambulances_onsite = []
                    self.emergency_response = None
                    self.graph = ox.graph_from_bbox(NORTH, SOUTH, EAST, WEST, network_type='drive')
                    self.fire_incidents = list()
                    self.fire_incidents_lock = threading.Lock()
                    self.police_incidents = list()
                    self.police_incidents_lock = threading.Lock()
            
                def deploy_citizens(self):
                    for i in range(self.citizens_number):
                        self.citizens.append(Citizen(i, self.graph, self.emergency_response))
                        self.citizens[i].start()
            
                def deploy_emergency_services(self):
                    # First, initialize the lists for firetrucks and police cars
                    self.firetrucks_onsite = [EmergencyVehicle(i, self.graph, "Fire-Truck", FIRE_STATION) for i in range(FIRE_TRUCKS)]
                    self.police_onsite = [EmergencyVehicle(i, self.graph, "Police-Car", POLICE_STATION) for i in range(POLICE_CARS)]
                    self.ambulances_onsite = [EmergencyVehicle(i, self.graph, "Ambulance", AMBULANCE_STATION) for i in range(AMBULANCES)]
                    
                    # Now you can pass these lists to the EmergencyResponseCenter
                    self.emergency_response = EmergencyResponseCenter(self.firetrucks_onsite, self.police_onsite, self.ambulances_onsite)
                    self.emergency_response.start()
            
                    # Start the firetrucks and police cars threads
                    for firetruck in self.firetrucks_onsite:
                        firetruck.start()
            
                    for police_car in self.police_onsite:
                        police_car.start()
            
                    for ambulance in self.ambulances_onsite:
                        ambulance.start()
            
                def start_services(self):
                    self.deploy_emergency_services()
                    self.deploy_citizens()

        ├── emergency_response_center.py
            -------------- CODE OF emergency_response_center.py --------------
            import threading
            from queue import PriorityQueue
            import time
            import random
            from models.incident import Incident
            from utils.constants import INCIDENTS
            
            class EmergencyResponseCenter(threading.Thread):
                _instance = None
            
                @classmethod
                def getInstance(cls, firetrucks=None, police_cars=None, ambulances=None):
                    if cls._instance is None:
                        cls._instance = cls(firetrucks, police_cars, ambulances)
                    return cls._instance
            
                def __init__(self, firetrucks, police_cars, ambulances):
                    if self._instance is not None:
                        raise Exception("This class is a singleton!")
                    else:
                        super().__init__()
                        self.incident_queue = PriorityQueue()
                        self.firetrucks = firetrucks
                        self.police_cars = police_cars
                        self.ambulances = ambulances
                        self.active_incidents = {}
                        self.lock = threading.RLock()
                        print("Emergency Response Center activated")
                        self._instance = self
                
                def run(self):
                    self.queue_listener()
            
            
                def queue_listener(self):
                    while True:
                        if not self.incident_queue.empty():
                            priority, incident_id = self.incident_queue.get()
                            print(f"The queue is: {self.incident_queue.queue}")
                            incident = self.active_incidents[incident_id]
                            print(f"Dispatching incident {incident.id} with priority {priority}")
                            if incident and incident.vehicles_needed != []:
                                threading.Thread(target=self.dispatch_vehicles, args=(incident,)).start()
                        time.sleep(0.1)
            
                def update_priorities(self):
                    with self.lock:
                        # Temporarily store updated incidents to put them back in the queue
                        updated_incidents = []
                        while not self.incident_queue.empty():
                            priority, incident_id = self.incident_queue.get()
                            updated_incidents.append((priority + 1, incident_id))  # Increase priority
            
                        # Put the updated incidents back in the queue
                        for incident in updated_incidents:
                            self.incident_queue.put(incident)
            
            
                def report_incident(self, incident_location):
                    # Now I will set the type of incident
                    incidents = INCIDENTS
                    incident_types = list(incidents.keys())
                    probabilities = [incidents[incident]['probability'] for incident in incident_types]
            
                    incident_type = random.choices(incident_types, weights=probabilities, k=1)[0]
                    id = len(self.active_incidents)
                    reported = time.time()
                    incident = Incident(id, incident_location, incident_type, reported, incidents[incident_type]['hardness'])
                    incident_priority = self.determine_incident_priority(incident_type, incident)
                    print(f"New incident reported at {incident_location} with type {incident_type} and priority {incident_priority}")
            
                    with self.lock:
                        self.active_incidents[id] = incident
                        self.incident_queue.put((incident_priority, incident.id))
            
                        
                def determine_incident_priority(self, incident_type, incident):
                    incident_details = INCIDENTS.get(incident_type, {})
            
                    # Get hardness and required resources for the incident
                    hardness = incident_details.get('hardness', 0)
                    required_police_cars = incident_details.get('required_police_cars', 0)
                    required_firetrucks = incident_details.get('required_firetrucks', 0)
                    required_ambulances = incident_details.get('required_ambulances', 0)
                    incident.vehicles_needed = [required_police_cars, required_firetrucks, required_ambulances]
            
                    # Calculate the number of available vehicles
                    available_police_cars = sum(1 for car in self.police_cars if car.available)
                    available_firetrucks = sum(1 for truck in self.firetrucks if truck.available)
                    available_ambulances = sum(1 for ambulance in self.ambulances if ambulance.available)
            
                    # Adjust priority based on availability of resources
                    # If fewer vehicles are available than required, the priority increases
                    priority_adjustment = 0
                    if available_police_cars < required_police_cars:
                        priority_adjustment += (required_police_cars - available_police_cars) * 10
                    if available_firetrucks < required_firetrucks:
                        priority_adjustment += (required_firetrucks - available_firetrucks) * 10
                    if available_ambulances < required_ambulances:
                        priority_adjustment += (required_ambulances - available_ambulances) * 10
            
                    # Final priority calculation
                    priority = 100 - hardness + priority_adjustment
            
                    return priority
            
                def dispatch_vehicles(self, incident):
                    # determine the number of vehicles needed for the incident
                    needed_police_cars = incident.vehicles_needed[0]
                    needed_firetrucks = incident.vehicles_needed[1]
                    needed_ambulances = incident.vehicles_needed[2]
            
                    # dispatch vehicles
                    dispatched_police_cars = 0
                    dispatched_firetrucks = 0
                    dispatched_ambulances = 0
            
                    # dispatch police cars
                    for car in self.police_cars:
                        car.lock.acquire()
                        if car.available and dispatched_police_cars < needed_police_cars:
                            car.attend_incident(incident)
                            dispatched_police_cars += 1
                        car.lock.release()
            
                    # dispatch firetrucks
                    for truck in self.firetrucks:
                        truck.lock.acquire()
                        if truck.available and dispatched_firetrucks < needed_firetrucks:
                            truck.attend_incident(incident)
                            dispatched_firetrucks += 1
                        truck.lock.release()
            
                    # dispatch ambulances
                    for ambulance in self.ambulances:
                        ambulance.lock.acquire()
                        if ambulance.available and dispatched_ambulances < needed_ambulances:
                            ambulance.attend_incident(incident)
                            dispatched_ambulances += 1
                        ambulance.lock.release()
            
                    # update incident status
                    incident.status = "dispatched"
                    incident.vehicles_dispatched = [dispatched_police_cars, dispatched_firetrucks, dispatched_ambulances]
                    incident.vehicles_needed = [needed_police_cars - dispatched_police_cars, needed_firetrucks - dispatched_firetrucks, needed_ambulances - dispatched_ambulances]
            
                    print(f"Dispatched {dispatched_police_cars} police cars, {dispatched_firetrucks} firetrucks, and {dispatched_ambulances} ambulances to incident {incident.id}")

        __pycache__/
            ├── emergency_response_center.cpython-310.pyc
                -------------- CODE OF emergency_response_center.cpython-310.pyc --------------
Failed to read emergency_response_center.cpython-310.pyc: 'utf-8' codec can't decode byte 0x89 in position 12: invalid start byte

            ├── city.cpython-310.pyc
                -------------- CODE OF city.cpython-310.pyc --------------
Failed to read city.cpython-310.pyc: 'utf-8' codec can't decode byte 0xe3 in position 16: invalid continuation byte

